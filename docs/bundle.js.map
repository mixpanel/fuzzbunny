{"version":3,"file":"bundle.js","mappings":";;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA,oDAAoD;AACpD,8DAA8D,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;;AAEA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA,SAAS,2BAA2B;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,cAAc,iCAAiC,QAAQ;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0DAA0D,mBAAmB;AAC7E;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,cAAc,qCAAqC,QAAQ;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,wCAAwC,gCAAgC;AACtF;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,yBAAyB;AACrC,aAAa;AACb;AACA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA,6DAA6D,eAAe;AAC5E;;AAEA;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uBAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA,kBAAkB;;;;;;;UC1WlB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA,QAAQ,cAAc,EAAE,mBAAO,CAAC,oCAAc;AAC9C;AACA;AACA,+CAA+C,GAAG;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,8BAA8B;AACnH;AACA;AACA,0BAA0B,8BAA8B;AACxD;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC,qDAAqD,kBAAkB;AACvE;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B,oBAAoB;AACrE,oCAAoC,KAAK;AACzC,sBAAsB;AACtB;AACA,+CAA+C,0CAA0C,aAAa,UAAU;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC","sources":["webpack://fuzzbunny/./fuzzbunny.js","webpack://fuzzbunny/webpack/bootstrap","webpack://fuzzbunny/./docs/index.ts"],"sourcesContent":["const SCORE_START_STR = 1000;\nconst SCORE_PREFIX = 200;\nconst SCORE_CONTIGUOUS = 300;\n\n/**\n * @param {number} idx - index of the match\n * @param {number} len - length of the match\n * @param {boolean} isPrefix - was it a prefix of a word\n * @returns {number} - score of the match, higher is better\n */\nfunction _getMatchScore(idx, len, isPrefix) {\n  let score = 0;\n\n  // increase score exponentially per letter matched so that contiguous matches are ranked higher\n  // i.e '[abc]' ranks higher than '[ab]ott [c]hemicals'\n  score += SCORE_CONTIGUOUS * len * len;\n\n  if (idx === 0) {\n    // matching at the start of string gets a ranking bonus\n    score += SCORE_START_STR;\n  } else if (isPrefix) {\n    // closer to the start, the higher it ranks\n    score += SCORE_PREFIX - idx;\n  }\n\n  return score;\n}\n\n// Ascii codes: <w_space>!\"#$%&'()*+,-./0123456789:;<=>?@\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\nconst CODE_a = `a`.charCodeAt(0);\nconst CODE_z = `z`.charCodeAt(0);\nconst CODE_A = `A`.charCodeAt(0);\nconst CODE_Z = `Z`.charCodeAt(0);\nconst CODE_0 = `0`.charCodeAt(0);\nconst CODE_9 = `9`.charCodeAt(0);\nconst CODE_EXCL_MARK = `!`.charCodeAt(0);\nconst CODE_SLASH = `/`.charCodeAt(0);\nconst CODE_COLON = `:`.charCodeAt(0);\nconst CODE_AT = `@`.charCodeAt(0);\nconst CODE_SQ_BKT = `[`.charCodeAt(0);\nconst CODE_CARET = `\\``.charCodeAt(0);\nconst CODE_CURLY_BKT = `{`.charCodeAt(0);\nconst CODE_TILDE = `~`.charCodeAt(0);\nconst CODE_START_UNICODE = 127;\n\n/**\n * @param {number} charCode\n * @returns {boolean}\n */\nfunction _isUpperCase(charCode) {\n  return charCode >= CODE_A && charCode <= CODE_Z;\n}\n\n/**\n * @param {number} charCode\n * @returns {boolean}\n */\nfunction _isCodeAlphaNum(charCode) {\n  // 0 - 126 charCodes are ascii, 127 onwards are unicode code points\n  return (\n    (charCode >= CODE_a && charCode <= CODE_z) ||\n    _isUpperCase(charCode) ||\n    (charCode >= CODE_0 && charCode <= CODE_9) ||\n    charCode >= CODE_START_UNICODE\n  );\n}\n\n/**\n * @param {number} charCode\n * @returns {boolean}\n */\nfunction _isCodePunctuation(charCode) {\n  // rather than create a uint8 typed array as a lookup table\n  // uglifyjs inlines this function in prod builds. JIT should inline too.\n  // we're calling it charCode rather than 'code' because of an uglifyjs bug\n  // see: https://github.com/mishoo/UglifyJS2/issues/2842\n  return (\n    (charCode >= CODE_EXCL_MARK && charCode <= CODE_SLASH) ||\n    (charCode >= CODE_COLON && charCode <= CODE_AT) ||\n    (charCode >= CODE_SQ_BKT && charCode <= CODE_CARET) ||\n    (charCode >= CODE_CURLY_BKT && charCode <= CODE_TILDE)\n  );\n}\n\n/**\n * A skip index marks word and punctuation boundaries\n * We use this to skip around the targetStr and quickly find prefix matches\n * @param {string} targetStr\n * @returns {number[]}\n */\nfunction _getTargetSkips(targetStr) {\n  const targetSkips = [];\n  let wasAlphaNum = false;\n  let wasUpperCase = false;\n\n  for (let i = 0, len = targetStr.length; i < len; ++i) {\n    const code = targetStr.charCodeAt(i);\n    const isAlphaNum = _isCodeAlphaNum(code);\n    const isUpperCase = _isUpperCase(code);\n\n    if ((isAlphaNum && !wasAlphaNum) || (isUpperCase && !wasUpperCase) || _isCodePunctuation(code)) {\n      targetSkips.push(i);\n    }\n\n    wasAlphaNum = isAlphaNum;\n    wasUpperCase = isUpperCase;\n  }\n\n  // We push the length as the last skip so when matching\n  // every range aligns between skip[i] and skip[i + 1]\n  // and we don't have to do extraneous overflow checks\n  targetSkips.push(targetStr.length);\n\n  // NOTE: these can possibly be cached on the items for a faster search next time\n  return targetSkips;\n}\n\n/**\n * performs a prefix match e.g 'usam' matches '[u]nited [s]tates of [am]erica\n * @param {number} skipIdx - skip index where to start search from\n * @param {string} searchStr - lowercased search string\n * @param {string} targetStr - lowercased target string\n * @param {number[]} targetSkips - skip boundary indices\n * @returns {number[] | null}\n *  - the [idx, len, ...] ranges where the match occured\n *  - null if no match found\n */\nfunction _fuzzyPrefixMatch(skipIdx, searchStr, targetStr, targetSkips) {\n  let searchIdx = 0;\n  const searchLen = searchStr.length;\n  /** @type {number[]} */\n  const ranges = [];\n\n  for (let skipLen = targetSkips.length - 1; skipIdx < skipLen; ++skipIdx) {\n    const startIdx = targetSkips[skipIdx];\n    const endIdx = targetSkips[skipIdx + 1];\n    let targetIdx = startIdx;\n    let matchLen = 0;\n\n    while (targetIdx < endIdx && searchIdx < searchLen) {\n      const targetChar = targetStr[targetIdx];\n      const searchChar = searchStr[searchIdx];\n\n      if (targetChar === searchChar) {\n        ++targetIdx;\n        ++searchIdx;\n        ++matchLen;\n        continue;\n      }\n\n      // spaces shouldn't break matching\n      if (targetChar === ` `) {\n        ++targetIdx;\n        continue;\n      }\n      if (searchChar === ` `) {\n        ++searchIdx;\n        continue;\n      }\n\n      break;\n    }\n\n    if (matchLen) {\n      // make contiguous ranges if possible\n      const rangesLen = ranges.length;\n      if (rangesLen >= 2 && ranges[rangesLen - 2] + ranges[rangesLen - 1] === startIdx) {\n        ranges[rangesLen - 1] += matchLen;\n      } else {\n        ranges.push(startIdx, matchLen);\n      }\n    }\n\n    if (searchIdx === searchLen) {\n      // search is fully matched, return ranges\n      return ranges;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Returns the string parts for highlighting from the matched ranges\n * @example ('my example', [3, 2]) would return ['my ', 'ex', 'ample']\n * @param {string} targetStr - the string that was matched\n * @param {number[]} ranges - [idx1, len1, idx2, len2] matched ranges\n * @returns {string[]} - ['no match', 'match', 'no match', 'match']\n */\nfunction highlightsFromRanges(targetStr, ranges) {\n  const highlights = [];\n  let lastIndex = 0;\n  let rangesIdx = 0;\n\n  for (; rangesIdx < ranges.length; rangesIdx += 2) {\n    const startIndex = ranges[rangesIdx];\n    const endIndex = startIndex + ranges[rangesIdx + 1];\n    highlights.push(targetStr.slice(lastIndex, startIndex));\n    highlights.push(targetStr.slice(startIndex, endIndex));\n    lastIndex = endIndex;\n  }\n\n  if (lastIndex < targetStr.length) {\n    highlights.push(targetStr.slice(lastIndex));\n  }\n\n  return highlights;\n}\n\n/**\n * fuzzyScoreItem is called by fuzzyMatch, it's a slightly lower level call\n * If perf is of importance and you want to avoid lowercase + trim + highlighting on every item\n * Use this and only call highlightsFromRanges for only the items that are displayed\n * @param {string} targetStr - lowercased trimmed target string to search on\n * @param {string} searchStr - lowercased trimmed search string\n * @returns {{score: number, ranges: number[]} | null} - null if no match\n */\nfunction fuzzyScoreItem(targetStr, searchStr) {\n  if (!targetStr) {\n    return null;\n  }\n\n  // empty search string is technically a match of nothing\n  if (!searchStr) {\n    return {\n      score: 0,\n      ranges: [],\n    };\n  }\n\n  // if user enters a quoted search then only perform substring match\n  // e.g \"la matches [{La}s Vegas] but not [Los Angeles]\n  // NOTE: ending quote is optional so user can get incremental matching as they type.\n  const isQuotedSearchStr = searchStr[0] === '\"';\n  if (isQuotedSearchStr) {\n    searchStr = searchStr.slice(1, searchStr.endsWith(`\"`) ? -1 : searchStr.length);\n  }\n\n  // try substring search first\n  // js engine uses boyer moore algo which is very fast O(m/n)\n  const lCaseTargetStr = targetStr.toLowerCase();\n  const matchIdx = lCaseTargetStr.indexOf(searchStr);\n  const searchLen = searchStr.length;\n\n  if (matchIdx >= 0) {\n    const isWordPrefix = matchIdx > 0 && !_isCodeAlphaNum(targetStr.charCodeAt(matchIdx - 1));\n    return {\n      score: _getMatchScore(matchIdx, searchLen, isWordPrefix),\n      ranges: [matchIdx, searchLen],\n    };\n  }\n\n  // if we didn't match a single character as a substr, we won't fuzzy match it either, exit early.\n  // if quoted search, exit after substring search as well, since user doesn't want fuzzy search.\n  if (searchLen === 1 || isQuotedSearchStr) {\n    return null;\n  }\n\n  // fall back to fuzzy matching which matches word prefixes or punctuations\n  // because we've precomputed targetSkips, its O(m+n) for avg case\n  // the skip array helps us make faster alignments, rather than letter by letter\n  const targetSkips = _getTargetSkips(targetStr);\n\n  for (let skipIdx = 0, skipLen = targetSkips.length - 1; skipIdx < skipLen; ++skipIdx) {\n    if (lCaseTargetStr[targetSkips[skipIdx]] === searchStr[0]) {\n      // possible alignment, perform prefix match\n      const ranges = _fuzzyPrefixMatch(skipIdx, searchStr, lCaseTargetStr, targetSkips);\n      if (ranges) {\n        let score = 0;\n        for (let i = 0, len = ranges.length; i < len; i += 2) {\n          score += _getMatchScore(ranges[i], ranges[i + 1], true /*isWordPrefix*/);\n        }\n        return {score, ranges};\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Fuzzy match and return the score, highlights, and lowercased matchStr (for sort)\n * @param {string} targetStr - target to search on / haystack string\n * @param {string} searchStr - search filter / needle string\n * @returns {{score: number, highlights: string[]} | null} - null if no match\n */\nfunction fuzzyMatch(targetStr, searchStr) {\n  targetStr = targetStr || ``;\n  searchStr = (searchStr || ``).trim().toLowerCase();\n  const match = fuzzyScoreItem(targetStr, searchStr);\n\n  if (match) {\n    return {\n      score: match.score,\n      highlights: highlightsFromRanges(targetStr, match.ranges),\n    };\n  }\n\n  return null;\n}\n\n/**\n * @template Item\n * @typedef {{item: Item, score: number, highlights: {[K in keyof Item]?: string[]}}} FuzzyFilterResult\n */\n\n/**\n * Searches an array of items on props and returns filtered + sorted array with scores and highlights\n * @template Item\n * @param {Item[]} items\n * @param {string} searchStr\n * @param {{fields: (keyof Item)[]}} options\n * @returns {FuzzyFilterResult<Item>[]}\n */\nfunction fuzzyFilter(items, searchStr, options) {\n  /** @type {FuzzyFilterResult<Item>[]} */\n  const results = [];\n  const searchStrLowerCased = (searchStr || ``).trim().toLowerCase();\n  const fields = options ? options.fields : null;\n  if (!fields || !Array.isArray(fields) || fields.length == 0) {\n    throw new Error(`invalid fields, did you forget to pass {fields: [...]} as options param?`);\n  }\n\n  for (const item of items) {\n    /** @type {FuzzyFilterResult<Item> | null} */\n    let result = null;\n    for (const field of fields) {\n      const value = item[field];\n      if (typeof value === `string` && value) {\n        const match = fuzzyScoreItem(value, searchStrLowerCased);\n        if (match) {\n          result = result || {item, score: 0, highlights: {}};\n          result.score = Math.max(match.score, result.score);\n          result.highlights[field] = highlightsFromRanges(value, match.ranges);\n        }\n      }\n    }\n    if (result) {\n      results.push(result);\n    }\n  }\n\n  // sort if searchStr is not empty, otherwise preserve original order, since its a pass through\n  if (searchStrLowerCased) {\n    results.sort((a, b) => {\n      // sort by score, then alphabetically by each field\n      let diff = b.score - a.score;\n      for (let i = 0, len = fields.length; diff === 0 && i < len; ++i) {\n        const field = fields[i];\n        const valA = a.item[field];\n        const valB = b.item[field];\n        // @ts-ignore string comparison\n        diff = (valA || ``).localeCompare(valB);\n      }\n      return diff;\n    });\n  }\n\n  return results;\n}\n\nmodule.exports = {fuzzyFilter, fuzzyMatch, fuzzyScoreItem, highlightsFromRanges};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// using require because typescript imports .d.ts for 'fuzzbunny' instead of module\n// this is only an issue because docs/index.ts references the module directly and not through node_modules/fuzzbunny\nconst { fuzzyFilter } = require(`../fuzzbunny`);\nconst NUM_INITIAL_ITEMS_TO_SHOW = 50;\nfunction getArticleUrl(id) {\n    return `https://www.gutenberg.org/ebooks/${id}`;\n}\nasync function fetchArticles() {\n    const storageKey = `gutenberg-catalog`;\n    const catalogUrl = `gutenberg-catalog.txt`;\n    // save in local storage for fast 2nd load\n    let catalog = localStorage.getItem(storageKey);\n    if (!catalog) {\n        catalog = await (await fetch(catalogUrl)).text();\n        localStorage.setItem(storageKey, catalog);\n    }\n    return catalog\n        .trim()\n        .split(`\\n`)\n        .slice(1) // ignore comment\n        .reverse()\n        .map((line) => {\n        // parse article's name and id into object\n        const [_, name, id] = line.match(/^(.*?)\\s+(\\d+)$/) || [];\n        return { name, id };\n    });\n}\nclass ArticleList {\n    constructor(articles, elRefs) {\n        this.searchFilterDebounceTimeout = -1;\n        this.state = {\n            articles,\n            numItemsToShow: NUM_INITIAL_ITEMS_TO_SHOW,\n            searchFilter: ``,\n        };\n        this.elRefs = elRefs;\n        this.elRefs.search.addEventListener(`input`, this.handleSearchInput.bind(this));\n        this.elRefs.results.addEventListener(`scroll`, this.handleResultsScroll.bind(this));\n        this.update({});\n    }\n    // Simple update -> render lifecycle;\n    update(props = {}) {\n        Object.assign(this.state, props);\n        this.render();\n    }\n    handleSearchInput(ev) {\n        this.elRefs.results.scrollTop = 0;\n        const searchFilter = ev.currentTarget.value;\n        const numItemsToShow = NUM_INITIAL_ITEMS_TO_SHOW;\n        // debounce searchFilter for 100ms if input length is <= 3\n        // for large set of results (>10k) the native js .sort() overheard could be >100ms\n        window.clearTimeout(this.searchFilterDebounceTimeout);\n        if (searchFilter && searchFilter.length <= 3) {\n            this.searchFilterDebounceTimeout = window.setTimeout(() => this.update({ searchFilter, numItemsToShow }), 100);\n        }\n        else {\n            this.update({ searchFilter, numItemsToShow });\n        }\n    }\n    handleResultsScroll(ev) {\n        const { articles, numItemsToShow } = this.state;\n        const resultsEl = this.elRefs.results;\n        const distanceToBottom = resultsEl.scrollHeight - resultsEl.clientHeight - resultsEl.scrollTop;\n        const distanceThreshold = 100;\n        if (distanceToBottom < distanceThreshold) {\n            this.update({\n                numItemsToShow: Math.min(numItemsToShow + NUM_INITIAL_ITEMS_TO_SHOW, articles.length),\n            });\n        }\n    }\n    fuzzyFilterArticles() {\n        const { articles, searchFilter } = this.state;\n        return fuzzyFilter(articles, searchFilter, { fields: [`name`] });\n    }\n    render() {\n        const { numItemsToShow } = this.state;\n        const startTime = Date.now();\n        const filteredArticles = this.fuzzyFilterArticles();\n        const elapsedMs = Date.now() - startTime;\n        this.elRefs.results.innerHTML = filteredArticles\n            .slice(0, numItemsToShow)\n            .map((match) => \n        // @ts-ignore - object possibly undefined (we're sure they're non-null)\n        `<a href='${getArticleUrl(match.item.id)}' target='_blank'>${match.highlights.name\n            .map((part) => `<span>${part}</span>`)\n            .join(``)}</a>`)\n            .join(``);\n        this.elRefs.stats.innerHTML = `Found ${filteredArticles.length.toLocaleString()} results in ${elapsedMs}ms`;\n    }\n}\ndocument.addEventListener(`DOMContentLoaded`, function () {\n    fetchArticles().then((articles) => {\n        new ArticleList(articles, {\n            search: document.querySelector(`.search`),\n            results: document.querySelector(`.results`),\n            stats: document.querySelector(`.stats`),\n        });\n    });\n});\n"],"names":[],"sourceRoot":""}