{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./docs/index.ts","webpack:///./fuzzbunny.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,OAAO,cAAc,GAAG,mBAAO,CAAC,oCAAc;AAC9C;AACA;AACA,+CAA+C,GAAG;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,eAAe,yCAAyC;AACxD,oDAAoD,oDAAoD;AACxG;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B,oBAAoB;AACrE,oCAAoC,KAAK;AACzC,sBAAsB;AACtB;AACA,+CAA+C,yCAAyC,cAAc,UAAU;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;;;;;;;;;;;AC3FD;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA,oDAAoD;AACpD,8DAA8D,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;;AAEA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA,QAAQ,2BAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,cAAc,gCAAgC,QAAQ;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yDAAyD,mBAAmB;AAC5E;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,cAAc,oCAAoC,QAAQ;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,wCAAwC,+BAA+B;AACrF;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,UAAU,eAAe;AACzB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,yBAAyB;AACpC,aAAa;AACb;AACA;AACA;AACA,OAAO,8BAA8B;AACrC,OAAO,0BAA0B;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA,SAAS,wBAAwB;;AAEjC;AACA,6DAA6D,cAAc;AAC3E;;AAEA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,wBAAwB,kBAAkB,wBAAwB;AACxG;AACA;AACA,0CAA0C,uBAAuB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;;AAEA,iBAAiB,aAAa;AAC9B;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./docs/index.ts\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// using require because typescript imports .d.ts for 'fuzzbunny' instead of module\n// this is only an issue because docs/index.ts references the module directly and not through node_modules/fuzzbunny\nconst { fuzzyFilter } = require(`../fuzzbunny`);\nconst NUM_INITIAL_ITEMS_TO_SHOW = 50;\nfunction getArticleUrl(id) {\n    return `https://www.gutenberg.org/ebooks/${id}`;\n}\nasync function fetchArticles() {\n    const storageKey = `gutenberg-catalog`;\n    const catalogUrl = `gutenberg-catalog.txt`;\n    // save in local storage for fast 2nd load\n    let catalog = localStorage.getItem(storageKey);\n    if (!catalog) {\n        catalog = await (await fetch(catalogUrl)).text();\n        localStorage.setItem(storageKey, catalog);\n    }\n    return catalog\n        .trim()\n        .split(`\\n`)\n        .slice(1) // ignore comment\n        .reverse()\n        .map((line) => {\n        // parse article's name and id into object\n        const [_, name, id] = line.match(/^(.*?)\\s+(\\d+)$/) || [];\n        return { name, id };\n    });\n}\nclass ArticleList {\n    constructor(articles, elRefs) {\n        this.state = {\n            articles,\n            numItemsToShow: NUM_INITIAL_ITEMS_TO_SHOW,\n            searchFilter: ``,\n        };\n        this.elRefs = elRefs;\n        this.elRefs.search.addEventListener(`input`, this.handleSearchInput.bind(this));\n        this.elRefs.results.addEventListener(`scroll`, this.handleResultsScroll.bind(this));\n        this.update({});\n    }\n    // Simple update -> render lifecycle;\n    update(props = {}) {\n        Object.assign(this.state, props);\n        this.render();\n    }\n    handleSearchInput(ev) {\n        this.elRefs.results.scrollTop = 0;\n        const searchFilter = ev.currentTarget.value;\n        const numItemsToShow = NUM_INITIAL_ITEMS_TO_SHOW;\n        this.update({ searchFilter, numItemsToShow });\n    }\n    handleResultsScroll(ev) {\n        const { articles, numItemsToShow } = this.state;\n        const resultsEl = this.elRefs.results;\n        const distanceToBottom = resultsEl.scrollHeight - resultsEl.clientHeight - resultsEl.scrollTop;\n        const distanceThreshold = 100;\n        if (distanceToBottom < distanceThreshold) {\n            this.update({\n                numItemsToShow: Math.min(numItemsToShow + NUM_INITIAL_ITEMS_TO_SHOW, articles.length),\n            });\n        }\n    }\n    fuzzyFilterArticles() {\n        const { articles, searchFilter, numItemsToShow } = this.state;\n        return fuzzyFilter(articles, searchFilter, { fields: [`name`], numResultsShown: numItemsToShow });\n    }\n    render() {\n        const { numItemsToShow } = this.state;\n        const startTime = Date.now();\n        const filteredArticles = this.fuzzyFilterArticles();\n        const elapsedMs = Date.now() - startTime;\n        this.elRefs.results.innerHTML = filteredArticles\n            .slice(0, numItemsToShow)\n            .map((match) => \n        // @ts-ignore - object possibly undefined (we're sure they're non-null)\n        `<a href='${getArticleUrl(match.item.id)}' target='_blank'>${match.highlights.name\n            .map((part) => `<span>${part}</span>`)\n            .join(``)}</a>`)\n            .join(``);\n        this.elRefs.stats.innerHTML = `Found ${filteredArticles.length.toLocaleString()} results in ${elapsedMs}ms`;\n    }\n}\ndocument.addEventListener(`DOMContentLoaded`, function () {\n    fetchArticles().then((articles) => {\n        new ArticleList(articles, {\n            search: document.querySelector(`.search`),\n            results: document.querySelector(`.results`),\n            stats: document.querySelector(`.stats`),\n        });\n    });\n});\n","const SCORE_START_STR = 1000;\nconst SCORE_PREFIX = 200;\nconst SCORE_CONTIGUOUS = 300;\n\n/**\n * @param {number} idx - index of the match\n * @param {number} len - length of the match\n * @param {boolean} isPrefix - was it a prefix of a word\n * @returns {number} - score of the match, higher is better\n */\nfunction _getMatchScore(idx, len, isPrefix) {\n  let score = 0;\n\n  // increase score exponentially per letter matched so that contiguous matches are ranked higher\n  // i.e '[abc]' ranks higher than '[ab]ott [c]hemicals'\n  score += SCORE_CONTIGUOUS * len * len;\n\n  if (idx === 0) {\n    // matching at the start of string gets a ranking bonus\n    score += SCORE_START_STR;\n  } else if (isPrefix) {\n    // closer to the start, the higher it ranks\n    score += SCORE_PREFIX - idx;\n  }\n\n  return score;\n}\n\n// Ascii codes: <w_space>!\"#$%&'()*+,-./0123456789:;<=>?@\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\nconst CODE_a = `a`.charCodeAt(0);\nconst CODE_z = `z`.charCodeAt(0);\nconst CODE_A = `A`.charCodeAt(0);\nconst CODE_Z = `Z`.charCodeAt(0);\nconst CODE_0 = `0`.charCodeAt(0);\nconst CODE_9 = `9`.charCodeAt(0);\nconst CODE_EXCL_MARK = `!`.charCodeAt(0);\nconst CODE_SLASH = `/`.charCodeAt(0);\nconst CODE_COLON = `:`.charCodeAt(0);\nconst CODE_AT = `@`.charCodeAt(0);\nconst CODE_SQ_BKT = `[`.charCodeAt(0);\nconst CODE_CARET = `\\``.charCodeAt(0);\nconst CODE_CURLY_BKT = `{`.charCodeAt(0);\nconst CODE_TILDE = `~`.charCodeAt(0);\nconst CODE_START_UNICODE = 127;\n\n/**\n * @param {number} charCode\n * @returns {boolean}\n */\nfunction _isUpperCase(charCode) {\n  return charCode >= CODE_A && charCode <= CODE_Z;\n}\n\n/**\n * @param {number} charCode\n * @returns {boolean}\n */\nfunction _isCodeAlphaNum(charCode) {\n  // 0 - 126 charCodes are ascii, 127 onwards are unicode code points\n  return (\n    (charCode >= CODE_a && charCode <= CODE_z) ||\n    _isUpperCase(charCode) ||\n    (charCode >= CODE_0 && charCode <= CODE_9) ||\n    charCode >= CODE_START_UNICODE\n  );\n}\n\n/**\n * @param {number} charCode\n * @returns {boolean}\n */\nfunction _isCodePunctuation(charCode) {\n  // rather than create a uint8 typed array as a lookup table\n  // uglifyjs inlines this function in prod builds. JIT should inline too.\n  // we're calling it charCode rather than 'code' because of an uglifyjs bug\n  // see: https://github.com/mishoo/UglifyJS2/issues/2842\n  return (\n    (charCode >= CODE_EXCL_MARK && charCode <= CODE_SLASH) ||\n    (charCode >= CODE_COLON && charCode <= CODE_AT) ||\n    (charCode >= CODE_SQ_BKT && charCode <= CODE_CARET) ||\n    (charCode >= CODE_CURLY_BKT && charCode <= CODE_TILDE)\n  );\n}\n\n/**\n * A skip index marks word and punctuation boundaries\n * We use this to skip around the targetStr and quickly find prefix matches\n * @param {string} targetStr\n * @returns {number[]}\n */\nfunction _getTargetSkips(targetStr) {\n  const targetSkips = [];\n  let wasAlphaNum = false;\n  let wasUpperCase = false;\n\n  for (let i = 0, len = targetStr.length; i < len; ++i) {\n    const code = targetStr.charCodeAt(i);\n    const isAlphaNum = _isCodeAlphaNum(code);\n    const isUpperCase = _isUpperCase(code);\n\n    if ((isAlphaNum && !wasAlphaNum) || (isUpperCase && !wasUpperCase) || _isCodePunctuation(code)) {\n      targetSkips.push(i);\n    }\n\n    wasAlphaNum = isAlphaNum;\n    wasUpperCase = isUpperCase;\n  }\n\n  // We push the length as the last skip so when matching\n  // every range aligns between skip[i] and skip[i + 1]\n  // and we don't have to do extraneous overflow checks\n  targetSkips.push(targetStr.length);\n\n  // NOTE: these can possibly be cached on the items for a faster search next time\n  return targetSkips;\n}\n\n/**\n * performs a prefix match e.g 'usam' matches '[u]nited [s]tates of [am]erica\n * @param {number} skipIdx - skip index where to start search from\n * @param {string} searchStr - lowercased search string\n * @param {string} targetStr - lowercased target string\n * @param {number[]} targetSkips - skip boundary indices\n * @returns {number[] | null}\n *  - the [idx, len, ...] ranges where the match occured\n *  - null if no match found\n */\nfunction _fuzzyPrefixMatch(skipIdx, searchStr, targetStr, targetSkips) {\n  let searchIdx = 0;\n  const searchLen = searchStr.length;\n  /** @type {number[]} */\n  const ranges = [];\n\n  for (let skipLen = targetSkips.length - 1; skipIdx < skipLen; ++skipIdx) {\n    const startIdx = targetSkips[skipIdx];\n    const endIdx = targetSkips[skipIdx + 1];\n    let targetIdx = startIdx;\n    let matchLen = 0;\n\n    while (targetIdx < endIdx && searchIdx < searchLen) {\n      const targetChar = targetStr[targetIdx];\n      const searchChar = searchStr[searchIdx];\n\n      if (targetChar === searchChar) {\n        ++targetIdx;\n        ++searchIdx;\n        ++matchLen;\n        continue;\n      }\n\n      // spaces shouldn't break matching\n      if (targetChar === ` `) {\n        ++targetIdx;\n        continue;\n      }\n      if (searchChar === ` `) {\n        ++searchIdx;\n        continue;\n      }\n\n      break;\n    }\n\n    if (matchLen) {\n      // make contiguous ranges if possible\n      const rangesLen = ranges.length;\n      if (rangesLen >= 2 && ranges[rangesLen - 2] + ranges[rangesLen - 1] === startIdx) {\n        ranges[rangesLen - 1] += matchLen;\n      } else {\n        ranges.push(startIdx, matchLen);\n      }\n    }\n\n    if (searchIdx === searchLen) {\n      // search is fully matched, return ranges\n      return ranges;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Returns the string parts for highlighting from the matched ranges\n * @example ('my example', [3, 2]) would return ['my ', 'ex', 'ample']\n * @param {string} targetStr - the string that was matched\n * @param {number[]} ranges - [idx1, len1, idx2, len2] matched ranges\n * @returns {string[]} - ['no match', 'match', 'no match', 'match']\n */\nfunction highlightsFromRanges(targetStr, ranges) {\n  const highlights = [];\n  let lastIndex = 0;\n  let rangesIdx = 0;\n\n  for (; rangesIdx < ranges.length; rangesIdx += 2) {\n    const startIndex = ranges[rangesIdx];\n    const endIndex = startIndex + ranges[rangesIdx + 1];\n    highlights.push(targetStr.slice(lastIndex, startIndex));\n    highlights.push(targetStr.slice(startIndex, endIndex));\n    lastIndex = endIndex;\n  }\n\n  if (lastIndex < targetStr.length) {\n    highlights.push(targetStr.slice(lastIndex));\n  }\n\n  return highlights;\n}\n\n/**\n * fuzzyScoreItem is called by fuzzyMatch, it's a slightly lower level call\n * If perf is of importance and you want to avoid lowercase + trim + highlighting on every item\n * Use this and only call highlightsFromRanges for only the items that are displayed\n * @param {string} targetStr - lowercased trimmed target string to search on\n * @param {string} searchStr - lowercased trimmed search string\n * @returns {{score: number, ranges: number[]} | null} - null if no match\n */\nfunction fuzzyScoreItem(targetStr, searchStr) {\n  if (!targetStr) {\n    return null;\n  }\n\n  // empty search string is technically a match of nothing\n  if (!searchStr) {\n    return {\n      score: 0,\n      ranges: [],\n    };\n  }\n\n  // if user enters a quoted search then only perform substring match\n  // e.g \"la matches [{La}s Vegas] but not [Los Angeles]\n  // NOTE: ending quote is optional so user can get incremental matching as they type.\n  const isQuotedSearchStr = searchStr[0] === '\"';\n  if (isQuotedSearchStr) {\n    searchStr = searchStr.slice(1, searchStr.endsWith(`\"`) ? -1 : searchStr.length);\n  }\n\n  // try substring search first\n  // js engine uses boyer moore algo which is very fast O(m/n)\n  const lCaseTargetStr = targetStr.toLowerCase();\n  const matchIdx = lCaseTargetStr.indexOf(searchStr);\n  const searchLen = searchStr.length;\n\n  if (matchIdx >= 0) {\n    const isWordPrefix = matchIdx > 0 && !_isCodeAlphaNum(targetStr.charCodeAt(matchIdx - 1));\n    return {\n      score: _getMatchScore(matchIdx, searchLen, isWordPrefix),\n      ranges: [matchIdx, searchLen],\n    };\n  }\n\n  // if we didn't match a single character as a substr, we won't fuzzy match it either, exit early.\n  // if quoted search, exit after substring search as well, since user doesn't want fuzzy search.\n  if (searchLen === 1 || isQuotedSearchStr) {\n    return null;\n  }\n\n  // fall back to fuzzy matching which matches word prefixes or punctuations\n  // because we've precomputed targetSkips, its O(m+n) for avg case\n  // the skip array helps us make faster alignments, rather than letter by letter\n  const targetSkips = _getTargetSkips(targetStr);\n\n  for (let skipIdx = 0, skipLen = targetSkips.length - 1; skipIdx < skipLen; ++skipIdx) {\n    if (lCaseTargetStr[targetSkips[skipIdx]] === searchStr[0]) {\n      // possible alignment, perform prefix match\n      const ranges = _fuzzyPrefixMatch(skipIdx, searchStr, lCaseTargetStr, targetSkips);\n      if (ranges) {\n        let score = 0;\n        for (let i = 0, len = ranges.length; i < len; i += 2) {\n          score += _getMatchScore(ranges[i], ranges[i + 1], true /*isWordPrefix*/);\n        }\n        return {score, ranges};\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Fuzzy match and return the score, highlights, and lowercased matchStr (for sort)\n * @param {string} targetStr - target to search on / haystack string\n * @param {string} searchStr - search filter / needle string\n * @returns {{score: number, highlights: string[]} | null} - null if no match\n */\nfunction fuzzyMatch(targetStr, searchStr) {\n  targetStr = targetStr || ``;\n  searchStr = (searchStr || ``).trim().toLowerCase();\n  const match = fuzzyScoreItem(targetStr, searchStr);\n\n  if (match) {\n    return {\n      score: match.score,\n      highlights: highlightsFromRanges(targetStr, match.ranges),\n    };\n  }\n\n  return null;\n}\n\n/**\n * @template Item\n * @typedef {{item: Item, score: number, highlights: {[K in keyof Item]?: string[]}}} FuzzyFilterResult\n */\n\n/**\n * @template Item\n * @typedef {Object} FuzzyFilterOptions\n * @prop {(keyof Item)[]} fields - fields of the item object that will be searched\n * @prop {number} [numResultsShown] - maximum number of results that will be displayed in UI.\n *   Since sorting large arrays is expensive, only top N results are sorted by score\n */\n\n/**\n * Searches an array of items on props and returns filtered + sorted array with scores and highlights\n * @template Item\n * @param {Item[]} items - list of objects to search on\n * @param {string} searchStr - the search string\n * @param {FuzzyFilterOptions<Item>} options - what fields to search on, and other options\n * @returns {FuzzyFilterResult<Item>[]}\n *\n * @example\n *  fuzzyFilter([\n *    {frist: 'Hello', last: 'World'},\n *    {frist: 'Foo', last: 'Bar'},\n *  ], {\n *    fields: ['first', 'last'],\n *  })\n */\nfunction fuzzyFilter(items, searchStr, options) {\n  /** @type {FuzzyFilterResult<Item>[]} */\n  let results = [];\n  const lcaseSearchStr = (searchStr || ``).trim().toLowerCase();\n  const {fields, numResultsShown} = options;\n\n  if (!fields || !Array.isArray(fields) || fields.length == 0) {\n    throw new Error(`invalid fields, did you forget to pass {fields: [...]} as options param?`);\n  }\n\n  for (const item of items) {\n    /** @type {FuzzyFilterResult<Item> | null} */\n    let result = null;\n    for (const field of fields) {\n      const value = item[field];\n      if (typeof value === `string` && value) {\n        const match = fuzzyScoreItem(value, lcaseSearchStr);\n        if (match) {\n          result = result || {item, score: 0, highlights: {}};\n          result.score = Math.max(match.score, result.score);\n          result.highlights[field] = highlightsFromRanges(value, match.ranges);\n        }\n      }\n    }\n    if (result) {\n      results.push(result);\n    }\n  }\n\n  // sort if searchStr is not empty, otherwise preserve original order, since its a pass through\n  if (lcaseSearchStr) {\n    const sortCompareFn = (/** @type {FuzzyFilterResult<Item>} */ a, /** @type {FuzzyFilterResult<Item>} */ b) => {\n      // sort by score, then alphabetically by each field\n      let diff = b.score - a.score;\n      for (let i = 0, len = fields.length; diff === 0 && i < len; ++i) {\n        const field = fields[i];\n        const valA = a.item[field];\n        const valB = b.item[field];\n        // @ts-ignore string comparison\n        diff = (valA || ``).localeCompare(valB);\n      }\n      return diff;\n    };\n\n    // reverse bubble sort is O(n^2), quick sort which v8 uses is O(n(log n))\n    // however if we're only sorting top X items, then bubble sort is O(Xn)\n    // which is much faster than sorting the full array if X is much smaller than n\n    if (numResultsShown && numResultsShown < results.length / 5) {\n      inPlaceTopNScoreSort(results, numResultsShown);\n    } else {\n      results.sort(sortCompareFn);\n    }\n  }\n\n  return results;\n}\n\n/**\n * Only sorts top N items in-place using bubble sort\n * @template Item\n * @param {Array<FuzzyFilterResult<Item>>} items - list of objects to search on\n * @param {number} numTopN\n * @returns {Array<FuzzyFilterResult<Item>>}\n */\nfunction inPlaceTopNScoreSort(items, numTopN) {\n  const numItems = items.length;\n\n  for (let n = 0; n < numTopN; ++n) {\n    let maxIdx = n;\n    let maxScore = items[maxIdx].score;\n    for (let i = n + 1; i < numItems; ++i) {\n      if (items[i].score > maxScore) {\n        maxIdx = i;\n        maxScore = items[maxIdx].score;\n      }\n    }\n    // swap n with maxIdx\n    let temp = items[n];\n    items[n] = items[maxIdx];\n    items[maxIdx] = temp;\n  }\n\n  return items;\n}\n\nmodule.exports = {fuzzyFilter, fuzzyMatch, fuzzyScoreItem, highlightsFromRanges};\n"],"sourceRoot":""}